name: Continuos integration and deployment
on: 
  push:
    branches:
      - develop
jobs:
  build:
    runs-on: ubuntu-20.04
    steps:
      - name: check out code
        uses: actions/checkout@v2
      - name: image build and push
        uses: docker/build-push-action@v1
        with:
          username: ${{ secrets.DOCKER_USER }}
          password: ${{ secrets.DOCKER_PASSWORD  }}
          repository: dictybase/auto-deploy
          add_git_labels: true
          tag_with_sha: true
          dockerfile: build/package/Dockerfile

  prepare-deploy:
    needs: build
    runs-on: ubuntu-20.04
    steps:
      - name: check out code
        uses: actions/checkout@v2
      - name: extract git sha
        id: git_sha
        run: |
          value=`git rev-parse --short HEAD`
          echo "::set-output name=git_sha_value::${value}"
      - name: set cluster name
        id: cluster
        uses: actions/github-script@v2
        with:
          github-token: ${{secrets.GITHUB_TOKEN}}
          script: |
            login = context.payload.sender.login
            core.setOutput("cluster_name","siddkube")
            if (login === "wildlifehexagon") {
              core.setOutput("cluster_name","erickube")
            }
      - name: prepare for deploy
        id: prepare_deploy
        uses: dictybase-docker/prepare-deploy@v1
        with:
          cluster-name: ${{ steps.cluster.outputs.cluster_name }}
          cluster-zone: "us-central1-a"
          namespace: dictybase
          chart-name: automan
          chart-path: deployments/charts/automan
          token: ${{secrets.GITHUB_TOKEN}}
          image-tag: sha-${{steps.git_sha.outputs.git_sha_value}}
          ref: ${{github.event.ref}} 
          artifact: "automan"


  deploy:
    needs: prepare-deploy
    runs-on: ubuntu-20.04
    steps:
      - name: check out code
        uses: actions/checkout@v2
      - name: download deployment artifact
        uses: actions/download-artifact@v2
        with:
          name: "automan"
      - name: extract information from deployment payload
        id: deploy_info
        uses: actions/github-script@v2
        with:
          github-token: ${{secrets.GITHUB_TOKEN}}
          script: |
            const path = require("path")
            const fsPromises = require("fs").promises
            const workspace = process.env.GITHUB_WORKSPACE
            const payload = path.join(workspace,"deployment.json")
            const raw = await fsPromises.readFile(payload,"utf-8")
            core.setOutput("deployment_id",json.id)
            core.setOutput("deployment_url",json.url)
            core.setOutput("cluster",json.payload.cluster)
            core.setOutput("zone",json.payload.zone)
            core.setOutput("chart",json.payload.chart)
            core.setOutput("namespace",json.payload.namespace)
            core.setOutput("image_tag",json.payload.image_tag)
            core.setOutput("path",json.payload.path)
      - name: create deployment status
        uses: actions/github-script@v2
        with:
          github-token: ${{secrets.GITHUB_TOKEN}}
          script: |
            github.repos.createDeploymentStatus({
                owner: context.repo.owner,
                repo: context.repo.repo,
                deployment_id: ${{ steps.deploy_info.outputs.deployment_id }},
                log_url: ${{ steps.deploy_info.outputs.deployment_url }},
                state: "in_progress",
                description: "deployment is in progress",
                mediaType: {
                    format: "application/vnd.github.flash-preview+json"
                }
            })
      - name: setup google cloud sdk
        uses: GoogleCloudPlatform/github-actions/setup-gcloud@master
        with:
          version: '293.0.0'
          project_id: ${{ secrets.PROJECT_ID }}
          service_account_key: ${{ secrets.SA_KEY }}
          export_default_credentials: true
      - name: set up helm 
        uses: azure/setup-helm@v1
        with:
          version: 'v2.16.7'
      - name: get credentials
        if: ${{ success() }}
        uses: actions/github-script@v2
        with:
          github-token: ${{secrets.GITHUB_TOKEN}}
          script: |
            const exec = require("@actions/exec")
            const gcloud = await io.which("gcloud", true)
            const args = [
                "container",
                "clusters",
                "get-credentials",
                ${{ steps.deploy_info.outputs.cluster }},
                "--zone",
                ${{ steps.deploy_info.outputs.zone }}
            ]
            await exec.exec(gcloud, args)
      - name: set presence of chart
        if: ${{ success() }}
        uses: actions/github-script@v2
        with:
          github-token: ${{secrets.GITHUB_TOKEN}}
          script: |
            const exec = require("@actions/exec")
            const helm = await io.which("helm", true)
            await exec.exec(helm, ["version"])
            const options = {}
            let output
            options.listeners = {
                stdout: (data) => {
                    output += data.toString()
                }
            }
            await exec.exec(helm, ["ls", ${{ steps.deploy_info.outputs.chart }}, "--output", "json"], options)
            core.setOutput("chart_upgrade","no")
            if (output) {
                json = JSON.parse(output)
                if json.Releases[0].Name === ${{ steps.deploy_info.outputs.chart }} {
                    core.setOutput("chart_upgrade","yes")
                }
            }
      - name: install or upgrade chart
        if: ${{ success() }}
        uses: actions/github-script@v2
        with:
          github-token: ${{secrets.GITHUB_TOKEN}}
          script: |
            const exec = require("@actions/exec")
            const helm = await io.which("helm", true)
            if ( ${{ steps.deploy_info.outputs.chart_upgrade }} === "yes") {
                await exec.exec(helm, [
                    "upgrade",
                    ${{ steps.deploy_info.outputs.chart }},
                    "--namespace",
                    ${{ steps.deploy_info.outputs.namespace }},
                    "--set",
                    'image.tag=' + ${{ steps.deploy_info.outputs.image_tag }},
                    ${{ steps.deploy_info.outputs.path }}
                ])
                core.debug('upgraded chart')
            } else {
                await exec.exec(helm,[
                    "install",
                    "--name",
                    ${{ steps.deploy_info.outputs.chart }},
                    "--namespace",
                    ${{ steps.deploy_info.outputs.namespace }},
                    "--set",
                    'image.tag=' + ${{ steps.deploy_info.outputs.image_tag }},
                    ${{ steps.deploy_info.outputs.path }}
                ])
                core.debug('installed chart')
            }
      - name: set successful deploy status
        if: ${{ success() }}
        uses: actions/github-script@v2
        with:
          github-token: ${{secrets.GITHUB_TOKEN}}
          script: |
            $github.repos.createDeploymentStatus({
                owner: context.repo.owner,
                repo: context.repo.repo,
                deployment_id: ${{ steps.deploy_info.outputs.deployment_id }},
                log_url: ${{ steps.deploy_info.outputs.deployment_url }},
                state: "success",
                description: "deployment is successful"
            })
      - name: set unsuccessful deploy status
        if: ${{ failure() }}
        uses: actions/github-script@v2
        with:
          github-token: ${{secrets.GITHUB_TOKEN}}
          script: |
            github.repos.createDeploymentStatus({
                owner: context.repo.owner,
                repo: context.repo.repo,
                deployment_id: ${{ steps.deploy_info.outputs.deployment_id }},
                log_url: ${{ steps.deploy_info.outputs.deployment_url }},
                state: "error",
                description: "deployment failed with error"
            })
